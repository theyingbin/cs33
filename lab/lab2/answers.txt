1. The instructions in the trace did not produce the correct mathematical result because Lisp objects are only 62 bits long. Our computation causes an overflow if it were to be stored in 62 bits but would not neccessarily overflow in the 64 bit case.  The instruction that caused the error is lea 0x0(,%rbp,4), %rax.
2. This is because 2305843009213693951 is represented by 2^61-1. If we look at the lisp.h source code, we find the following line of code: #define MOST_POSITIVE_FIXNUM (EMACS_INT_MAX >> INTTYPEBITS). For 64 bit machines, the value of EMACS_INT_MAX is 0x7fffffffffffffff. We shift this value to the right by INTTYPEBITS which is GCTYPEBITS-1. GCTYPEBITS happens to be 3 so we essentially shift EMACS_INT_MAX right by 2. This results in the value 2^61-1 or 2305843009213693951.
3. The pattern used for squaring numbers is bit shifting then adding a one. In our case, if we square most_positive_fixnum, it will shift it until the binary representation consist of a bit vector of zeros. If we then add one to that, the result will be 1.
4. If the executable was compiled with the -fsanitize=undefined flag, it would output an runtime error message whenever overflow occurs. It allows execution to continue. However, since there was no overflow detected in our trace, this flag does not change anything. 
5. If the executable was compiled with the -fwrapv flag, the compiler just allows arithmetic operations to be done without checking for overflow. However, since there was no overflow detected in our trace, there won't be any problems. 
6. If -fwrapv is used, the compiler does binary arithmetic without checking for overflow. Because of this, we can skip all the overflow checks and simply multiply. 
7. Since there are only 2-3 overflow checks in the form of switch statements, removing them won't have a drastic effect on the efficiency. The code may speed up a little but it would be unnoticeable. 